# Документация по грамматике языка 1С

## 1. Введение

Данный документ содержит описание грамматики языка 1С:Предприятие, используемой в проекте AST Creator. Документация охватывает структуру грамматики, поддерживаемые конструкции языка, систему версионирования и принципы расширения грамматики с помощью AI-агентов.

## 2. Общая структура грамматики

Грамматика 1С, используемая в проекте, определена в формате Lark и строится по следующим принципам:

1. Весь код разбирается на верхнеуровневые конструкции: объявления переменных, процедур, функций и другие типы операторов.
2. Каждая конструкция описывается одним или несколькими правилами грамматики.
3. Для разбора используется LALR-парсер, обеспечивающий хороший баланс между скоростью и выразительностью.
4. Грамматика поддерживает как латинские, так и кириллические идентификаторы.

## 3. Основные правила грамматики

### 3.1. Стартовое правило

```lark
start: statement*
```

Стартовое правило `start` определяет, что программа на 1С состоит из последовательности операторов (statements).

### 3.2. Объявление переменных

```lark
var_declaration: "Перем" IDENTIFIER ";"?
```

Правило описывает объявление переменной, которое начинается ключевым словом "Перем", за которым следует идентификатор и опциональная точка с запятой.

### 3.3. Присваивание

```lark
assignment: IDENTIFIER "=" expression ";"?
```

Оператор присваивания состоит из идентификатора, знака равенства, выражения и опциональной точки с запятой.

### 3.4. Условные конструкции

```lark
if_statement: "Если" expression "Тогда" statement+ ["Иначе" statement+] "КонецЕсли" ";"?
```

Условная конструкция начинается с ключевого слова "Если", за которым следует выражение-условие, ключевое слово "Тогда", тело условия, опциональный блок "Иначе" и завершающее ключевое слово "КонецЕсли".

### 3.5. Циклы

```lark
for_statement: "Для" IDENTIFIER "=" expression "По" expression "Цикл" statement+ "КонецЦикла" ";"?
while_statement: "Пока" expression "Цикл" statement+ "КонецЦикла" ";"?
```

Определены два типа циклов: цикл со счетчиком (Для) и цикл с условием (Пока).

### 3.6. Объявление процедур и функций

```lark
proc_declaration: "Процедура" IDENTIFIER "(" [params] ")" [export] statement* "КонецПроцедуры"
func_declaration: "Функция" IDENTIFIER "(" [params] ")" [export] statement* "КонецФункции"
```

Объявления процедур и функций включают имя, параметры, опциональное ключевое слово "Экспорт", тело и завершающее ключевое слово.

### 3.7. Выражения

```lark
expression: IDENTIFIER | NUMBER | STRING | comparison | arithmetic | call_expression
comparison: expression COMPARE_OP expression
arithmetic: expression (ADD_OP | MUL_OP) expression
```

Выражения могут быть идентификаторами, числами, строками, сравнениями, арифметическими выражениями или вызовами функций.

### 3.8. Идентификаторы и литералы

```lark
IDENTIFIER: /[а-яА-Яa-zA-Z_][а-яА-Яa-zA-Z0-9_]*/
NUMBER: /\d+(\.\d+)?/
STRING: /"[^"]*"/
```

Определения токенов для идентификаторов, чисел и строк.

## 4. Система версионирования грамматики

### 4.1. Принципы работы

Система версионирования грамматики основана на следующих принципах:

1. Каждая версия грамматики сохраняется как отдельный JSON-файл в специальной директории.
2. Версии имеют уникальные идентификаторы, временные метки и описания изменений.
3. Поддерживается откат к предыдущим версиям грамматики.
4. Реализовано автоматическое создание резервных копий.

### 4.2. Класс GrammarVersion

Класс `GrammarVersion` представляет версию грамматики и содержит следующие атрибуты:

- `grammar` - строка с грамматикой в формате Lark
- `description` - описание версии
- `created_by` - идентификатор создателя версии (ручное, AI-агент)
- `version_id` - уникальный идентификатор версии
- `timestamp` - временная метка создания

### 4.3. Класс GrammarManager

Класс `GrammarManager` управляет версиями грамматики и обеспечивает следующую функциональность:

- Загрузка и сохранение версий грамматики
- Создание новых версий
- Откат к предыдущим версиям
- Расширение грамматики новыми правилами
- Резервное копирование

## 5. Расширение грамматики с помощью AI-агентов

### 5.1. Принципы работы AI-агентов

AI-агенты используются для автоматического расширения грамматики при обнаружении неизвестных конструкций языка. Процесс работает следующим образом:

1. При возникновении ошибки парсинга агент анализирует код и ошибку.
2. Агент генерирует новое правило грамматики для поддержки неизвестной конструкции.
3. Правило валидируется для проверки его корректности.
4. В случае успешной валидации правило добавляется в грамматику как новая версия.

### 5.2. Класс GrammarAgent

Класс `GrammarAgent` реализует логику работы с AI для расширения грамматики:

- `analyze_parse_error` - анализирует ошибку парсинга и возвращает информацию о неизвестной конструкции
- `generate_grammar_rule` - генерирует новое правило грамматики
- `validate_grammar_rule` - проверяет корректность нового правила
- `process_unknown_construct` - интегрирует новое правило в грамматику
- `export_grammar_to_file` - экспортирует текущую грамматику в файл

### 5.3. Класс AgentCoordinator

Класс `AgentCoordinator` координирует работу AI-агентов и их взаимодействие с системой грамматики:

- Обработка ошибок парсинга
- Управление жизненным циклом агентов
- Экспорт грамматики
- Интеграция с системой версионирования

## 6. Примеры использования

### 6.1. Парсинг кода на 1С

```python
from ast_create.grammar.parser import Parser

# Создаем экземпляр парсера
parser = Parser()

# Парсим код
code = """
Перем Счетчик;

Процедура УвеличитьСчетчик()
    Счетчик = Счетчик + 1;
КонецПроцедуры
"""

# Получаем синтаксическое дерево
tree = parser.parse(code)
```

### 6.2. Работа с версиями грамматики

```python
from ast_create.grammar.parser import Parser

# Создаем экземпляр парсера
parser = Parser()

# Получаем список доступных версий
versions = parser.get_available_versions()

# Откатываемся к определенной версии
parser.rollback_to_version(versions[0]["version_id"])

# Экспортируем текущую грамматику в файл
parser.export_grammar("exported_grammar.lark")
```

### 6.3. Обработка ошибок парсинга

```python
from ast_create.grammar.parser import Parser

# Создаем экземпляр парсера с включенными AI-агентами
parser = Parser(use_agents=True)

# Пытаемся распарсить код, который может содержать ошибки
success, tree, error = parser.try_parse(code)

if not success:
    print(f"Ошибка парсинга: {error}")
else:
    print("Парсинг успешен")
```

## 7. Расширение грамматики

### 7.1. Ручное расширение

Для ручного расширения грамматики можно использовать метод `extend_grammar` менеджера грамматики:

```python
from ast_create.grammar.grammar_manager import get_grammar_manager

# Получаем менеджер грамматики
grammar_manager = get_grammar_manager()

# Новое правило
new_rule = """
// Правило для цикла "Для каждого"
foreach_statement: "Для" "каждого" IDENTIFIER "Из" expression "Цикл" statement+ "КонецЦикла" ";"?

// Обновление правила statement
?statement: var_declaration | assignment | if_statement | foreach_statement
"""

# Расширяем грамматику
grammar_manager.extend_grammar(
    new_rule, 
    "Добавление поддержки цикла 'Для каждого'",
    "manual"
)
```

### 7.2. Автоматическое расширение

Для включения автоматического расширения грамматики с помощью AI-агентов настройте соответствующий параметр в конфигурации:

```python
from ast_create.config import config

# Включаем AI-агенты
config.agent.enabled = True

# Включаем автоматическое обновление грамматики
config.agent.auto_update_grammar = True
```

## 8. Заключение

Данная документация предоставляет обзор грамматики языка 1С, используемой в проекте AST Creator, а также описывает систему версионирования и принципы расширения грамматики с помощью AI-агентов. При дальнейшем развитии проекта документация будет обновляться в соответствии с новыми возможностями и изменениями в грамматике. 